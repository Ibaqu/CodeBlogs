# Configuration Model for unit testing a Ballerina project

Testing is an intrinsic part of any project that is planned to run in production. In the least, a project should be verified with unit tests and integration tests before deploying it to production.

Unit tests would ensure the functions and services of individual modules are working as expected and therefore when developing a project, unit tests should be a part of the project. Modules exposed by other modules or completely external endpoints can be mocked when running unit tests since the objective is to test the functionality of the current module.  Therefore, there can be more than one configuration for the module: one for running the module which would have actual endpoints, credentials, etc and another with mocks of these which will be used for unit tests.

## Deciding on the project structure

A developer may choose a project structure of his convenience based on his development practices. A developer may choose to have configuration files per module or a single file for the entire project. An important point to keep in mind when deciding on the project structure is that, not just the source code but also the unit tests are a part of the project structure. Hence unit testing the project should not possess cumbersome tweaks to the configurations or hardcoded values.

### Maintaining configurations for different phases

A project consists of a life-cycle built upon different goals or phases such as build, test and run. Each of these goals are there for different purposes and all of them are run at a certain point before the project is ready to deploy. Designing a project structure with a pluggable configuration model would make it convenient apply the appropriate configurations required for each of these phases of the life-cycle.

[Ballerina Config Module](https://ballerina.io/learn/by-example/config-api.html) facilitates writing projects with a pluggable configuration model. The configurations can be given either as environment variables, CLI arguments, or in a file. The config API can be used to define separate configuration files for different goals of the project, in this case for running and testing. The user has the ability to pass the appropriate configuration file as a key-value pair `--b7a.config.file=<path-to-config-file>` to the command. Having a project structure with a pluggable configuration model becomes handy when the developer has the ability to switch between different configurations seamlessly when it is required.

### Importance of code coverage for unit tests

Another important point when running unit tests is that apart from verifying the functionality of the project, it is essential to get an extensive test coverage of the source code taking into account as many possibilities in the happy path as well as the sad path. The code coverage report generated by the Ballerina test framework can aid in this regard as it provides a detailed report on the coverage of the source code which can be used as a metric to entrust the functionally of individual modules. Code coverage report can be generated for the entire project or for a single module by passing the `--code-coverage` flag to the ballerina build and ballerina test commands. For details on generating the code coverage report please refer to the [official documentation on the Ballerina test framework](https://ballerina.io/learn/how-to-test-ballerina-code/).
 
If the developer chooses to write separate configuration files for each module, then it would be impossible to get the code coverage for the entire project since the entire project cannot rely on a single set of configurations. Hence, the need for code coverage report in both module and project level further depicts that when having multiple configuration files, it would also be worth maintaining a single configuration file for unit tests as it would be convenient to get the code coverage reports.

## Designing a project with a pluggable configuration model
A simple travel agency project can be taken as an example of a project designed with a pluggable configuration model that is convenient for testing and running. This project focuses on two basic use cases of reservation: reservation creation and reservation cancellation.The complete source code of the project is available [here](https://github.com/Ibaqu/CodeBlogs/tree/master/Test_Config_Blog/TravelAgencyProject).

### Source code

The project contains two modules and each module contains a service.  The basic reservation scenario and the functionality of modules for these are as follows:


**Use Case**: Create a reservation

**Module functionality**: When a user requests a reservation, the travel agency reservation API is invoked which then will respond with a success message and send the user a confirmation email via the email service.

The source code is organized into two modules based on the API functionality.

**_TravelAgencyModule_**

Implements a service to add reservations via an external airline reservation API

**_EmailModule_**

Implements a service for email sending. This module is used by the TravelAgencyModule to send confirmation emails to the customer.

### Related Configurations

TravelAgencyModule
* Travel agency service related configurations (eg: host, port)
* Airline reservation service related configurations
* Mail sender service related configurations

EmailModule
* Mail sender service related configurations
* SMTP configurations such as host, port, username, password

### Unit tests

Each module should contain unit tests relevant to that particular module, and thus there should be a `tests/` directory under each module containing the unit tests for that particular module.

When writing unit tests, the following services and clients can be mocked in each module.

TravelAgencyModule
* Email sender service
* Airline reservation service

EmailModule
* SMTP client object

### Pluggable Configuration model

The project contains two modules which have to be unit tested and run independently. The main phases of the life-cycle of the project before it can be deployed will be `build` and `run` since the build phase will compile, generate executables and run the tests. Therefore, there should be two different configuration sets, one with mock configurations used for building the module and the other containing the actual configurations used for running the module.

We can organize the configuration into a separate directory named `conf/`and switch between them when executing the build and run commands. Also, sticking to a single configuration file for each phase makes it seamless to get code coverage reports for both individual modules and the entire project.

With the above considerations in mind, the travel agency project is structured as follows:

```
TravelAgencyProject/
├── Ballerina.toml
├── conf
│   ├── ballerina-run.toml
│   └── ballerina-test.toml
└── src
    ├── EmailModule
    │   ├── mail_sender_service.bal
    │   └── tests
    │       ├── mail_api_test.bal
    │       └── MockObjects
    │           └── mock_objects.bal
    └── TravelAgencyModule
        ├── tests
        │   ├── MockServices
        │   │   └── mock_services.bal
        │   └── travel_agency_service_test.bal
        └── travel_agency_service.bal

```
### Execution of different phases

With multiple configuration files, each phase of the TravelAgencyProject will be provided with the relevant configuration file as shown below.

#### Building the project or individual modules

`ballerina build --code-coverage --all --b7a.config.file=conf/ballerina-test.toml`

or

`ballerina build --code-coverage  <module-name> --b7a.config.file=conf/ballerina-test.toml`


#### Running each module in the project

`ballerina run <module-name> --b7a.config.file=conf/ballerina-run.toml`

## Key Takeaways

The following points should be considered when deciding on a structure for a ballerina project

* When designing a project structure it is important to make it testable
* A Ballerina project has mainly two phases before making a project ready for deployment: build (compile, generate executables and test) and run
* Different phases of the project require different configurations and therefore the project is preferred to have a pluggable configuration model
* The configuration model should also support generation of code coverage at module level as well as the project level which demands a single configuration file for all modules for each phase or at least for testing (build phase)
